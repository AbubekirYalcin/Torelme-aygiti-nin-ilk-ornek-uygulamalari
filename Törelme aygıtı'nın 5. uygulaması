import tkinter as tk
from tkinter import ttk, messagebox
import re
import json
from uuid import uuid4

class TersTorenmelikBagmaToplamiOnaylayicisi: #
    def __init__(self, root):
        self.root = root
        self.root.title("Ters törelmelik Bağma Toplamı Onaylayıcısı - Uygulama 5") #
        self.valid_statement_source_pairs = {
            'AT31': 'KN30', 'AT32': 'KN31', 'AT33': 'KN32', 'AT34': 'KN33',
            'AT43': 'KN42', 'AT44': 'KN43', 'AT45': 'KN44', 'AT46': 'KN45',
            'AT47': 'KN46', 'AT48': 'KN47', 'AT49': 'KN48', 'AT50': 'KN49',
            'AT52': 'KN51', 'AT54': 'KN53', 'AT56': 'KN55', 'AT58': 'KN57',
            'AT59': 'KN58', 'AT60': 'KN59', 'AT61': 'KN60', 'AT62': 'KN61',
            'AT63': 'KN62', 'AT64': 'KN63', 'AT65': 'KN64', 'AT66': 'KN65',
            'AT67': 'KN66', 'AT68': 'KN67', 'AT69': 'KN68', 'AT70': 'KN69',
            'AT71': 'KN70', 'AT72': 'KN71', 'AT73': 'KN72', 'AT74': 'KN73'
        } # [cite: 3882-3913]
        self.valid_statement_value_pairs = {
            'AT31': {'values': ['DR31'], 'required': 'DR31'},
            'AT32': {'values': ['DR31', 'DR32'], 'required': 'DR32'},
            'AT33': {'values': ['DR33'], 'required': 'DR33'},
            'AT34': {'values': ['DR31', 'DR32', 'DR33', 'DR34'], 'required': 'DR34'},
            'AT43': {'values': ['DR43'], 'required': 'DR43'},
            'AT44': {'values': ['DR43', 'DR44'], 'required': 'DR44'},
            'AT45': {'values': ['DR45'], 'required': 'DR45'},
            'AT46': {'values': ['DR43', 'DR44', 'DR45', 'DR46'], 'required': 'DR46'},
            'AT47': {'values': ['DR47'], 'required': 'DR47'},
            'AT48': {'values': ['DR47', 'DR48'], 'required': 'DR48'},
            'AT49': {'values': ['DR47', 'DR48', 'DR49'], 'required': 'DR49'},
            'AT50': {'values': ['DR47', 'DR48', 'DR49', 'DR50'], 'required': 'DR50'},
            'AT52': {'values': ['DR52'], 'required': 'DR52'},
            'AT54': {'values': ['DR54'], 'required': 'DR54'},
            'AT56': {'values': ['DR56'], 'required': 'DR56'},
            'AT58': {'values': ['DR58'], 'required': 'DR58'},
            'AT59': {'values': ['DR59'], 'required': 'DR59'},
            'AT60': {'values': ['DR59', 'DR60'], 'required': 'DR60'},
            'AT61': {'values': ['DR61'], 'required': 'DR61'},
            'AT62': {'values': ['DR59', 'DR60', 'DR61', 'DR62'], 'required': 'DR62'},
            'AT63': {'values': ['DR63'], 'required': 'DR63'},
            'AT64': {'values': ['DR63', 'DR64'], 'required': 'DR64'},
            'AT65': {'values': ['DR65'], 'required': 'DR65'},
            'AT66': {'values': ['DR63', 'DR64', 'DR65', 'DR66'], 'required': 'DR66'},
            'AT67': {'values': ['DR67'], 'required': 'DR67'},
            'AT68': {'values': ['DR67', 'DR68'], 'required': 'DR68'},
            'AT69': {'values': ['DR69'], 'required': 'DR69'},
            'AT70': {'values': ['DR67', 'DR68', 'DR69', 'DR70'], 'required': 'DR70'},
            'AT71': {'values': ['DR71'], 'required': 'DR71'},
            'AT72': {'values': ['DR71', 'DR72'], 'required': 'DR72'},
            'AT73': {'values': ['DR73'], 'required': 'DR73'},
            'AT74': {'values': ['DR71', 'DR72', 'DR73', 'DR74'], 'required': 'DR74'}
        } # [cite: 3882-3913]
        self.valid_interaction_tags = (
            [f"EM0{i}" for i in range(4, 8)] + #
            [f"UY{i}" for i in range(32, 64)] + #
            [f"TK0{i}" for i in range(4, 8)] + #
            [f"OM{i:02d}" for i in range(8, 16)] + #
            [f"OL{i:02d}" for i in range(8, 16)] #
        )
        self.valid_means_tags = ["UR02", "UR03"] #
        self.valid_displayment_tags = ["GM02", "GM03"] #
        self.valid_set_types = ["Etkilenmeyen", "Uygulayan", "Tekrarlayan", "Onaylamayan", "Onaylayan"] #
        self.conversion_rules = {
            'OL08': ['OM08', 'OM12'], 'OL09': ['OM09', 'OM13'], 'OL10': ['OM10', 'OM14'], 'OL11': ['OM11', 'OM15'],
            'OL12': ['OM08', 'OM12'], 'OL13': ['OM09', 'OM13'], 'OL14': ['OM10', 'OM14'], 'OL15': ['OM11', 'OM15'],
            'OM08': ['OL08', 'OL12'], 'OM09': ['OL09', 'OL13'], 'OM10': ['OL10', 'OL14'], 'OM11': ['OL11', 'OL15'],
            'OM12': ['OL08', 'OL12'], 'OM13': ['OL09', 'OL13'], 'OM14': ['OL10', 'OL14'], 'OM15': ['OL11', 'OL15']
        } # [cite: 3953-3969]
        self.transformation_rules = {
            'EM04': ['EM06'], 'EM05': ['EM07'], 'EM06': ['EM04'], 'EM07': ['EM05'],
            'UY32': ['UY34', 'UY36', 'UY38'], 'UY33': ['UY35', 'UY37', 'UY39'], 'UY34': ['UY32', 'UY36', 'UY38'],
            'UY35': ['UY33', 'UY37', 'UY39'], 'UY36': ['UY32', 'UY34', 'UY38'], 'UY37': ['UY33', 'UY35', 'UY39'],
            'UY38': ['UY32', 'UY34', 'UY36'], 'UY39': ['UY33', 'UY35', 'UY37'], 'UY40': ['UY42', 'UY44', 'UY46'],
            'UY41': ['UY43', 'UY45', 'UY47'], 'UY42': ['UY40', 'UY44', 'UY46'], 'UY43': ['UY41', 'UY45', 'UY47'],
            'UY44': ['UY40', 'UY42', 'UY46'], 'UY45': ['UY41', 'UY43', 'UY47'], 'UY46': ['UY40', 'UY42', 'UY44'],
            'UY47': ['UY41', 'UY43', 'UY45'], 'UY48': ['UY50', 'UY52', 'UY54'], 'UY49': ['UY51', 'UY53', 'UY55'],
            'UY50': ['UY48', 'UY52', 'UY54'], 'UY51': ['UY49', 'UY53', 'UY55'], 'UY52': ['UY48', 'UY50', 'UY54'],
            'UY53': ['UY49', 'UY51', 'UY55'], 'UY54': ['UY48', 'UY50', 'UY52'], 'UY55': ['UY49', 'UY51', 'UY53'],
            'UY56': ['UY58', 'UY60', 'UY62'], 'UY57': ['UY59', 'UY61', 'UY63'], 'UY58': ['UY56', 'UY60', 'UY62'],
            'UY59': ['UY57', 'UY61', 'UY63'], 'UY60': ['UY56', 'UY58', 'UY62'], 'UY61': ['UY57', 'UY59', 'UY63'],
            'UY62': ['UY56', 'UY58', 'UY60'], 'UY63': ['UY57', 'UY59', 'UY61'],
            'OM08': ['OM12'], 'OM09': ['OM13'], 'OM10': ['OM14'], 'OM11': ['OM15'],
            'OM12': ['OM08'], 'OM13': ['OM09'], 'OM14': ['OM10'], 'OM15': ['OM11'],
            'OL08': ['OL12'], 'OL09': ['OL13'], 'OL10': ['OL14'], 'OL11': ['OL15'],
            'OL12': ['OL08'], 'OL13': ['OL09'], 'OL14': ['OL10'], 'OL15': ['OL11'],
            'TK04': [], 'TK05': [], 'TK06': [], 'TK07': []
        } # [cite: 3974-4033]
        self.forward_conversion_rules = {}
        for current_tag, prev_list in self.conversion_rules.items():
            for prev_tag in prev_list:
                if prev_tag not in self.forward_conversion_rules:
                    self.forward_conversion_rules[prev_tag] = []
                self.forward_conversion_rules[prev_tag].append(current_tag)
        self.forward_transformation_rules = {}
        for current_tag, prev_list in self.transformation_rules.items():
            for prev_tag in prev_list:
                if prev_tag not in self.forward_transformation_rules:
                    self.forward_transformation_rules[prev_tag] = []
                self.forward_transformation_rules[prev_tag].append(current_tag)
        self.tabs = {}
        self.sets = {}
        self.setup_gui()

    def setup_gui(self):
        canvas_frame = ttk.Frame(self.root)
        canvas_frame.pack(fill=tk.BOTH, expand=True)
        self.canvas = tk.Canvas(canvas_frame)
        v_scrollbar = ttk.Scrollbar(canvas_frame, orient=tk.VERTICAL, command=self.canvas.yview)
        self.canvas.configure(yscrollcommand=v_scrollbar.set)
        v_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.main_frame = ttk.Frame(self.canvas)
        self.canvas.create_window((0, 0), window=self.main_frame, anchor="nw")
        self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=10, pady=10)

        self.main_frame.bind("<Configure>", lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all")))
        def on_mousewheel(event):
            if event.delta:
                self.canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")
            elif event.num == 4:
                self.canvas.yview_scroll(-1, "units")
            elif event.num == 5:
                self.canvas.yview_scroll(1, "units")
        self.canvas.bind_all("<MouseWheel>", on_mousewheel)
        self.canvas.bind_all("<Button-4>", on_mousewheel)
        self.canvas.bind_all("<Button-5>", on_mousewheel)

        button_frame = ttk.Frame(self.main_frame)
        button_frame.pack(fill=tk.X, pady=5)
        ttk.Button(button_frame, text="Toplam Ekle", command=self.add_set).pack(side=tk.LEFT, padx=5) #
        ttk.Button(button_frame, text="Sekme Ekle", command=self.add_tab).pack(side=tk.LEFT, padx=5) #
        ttk.Button(button_frame, text="Sekmeyi Doğrula", command=self.validate_tab).pack(side=tk.LEFT, padx=5) #
        ttk.Button(button_frame, text="Toplamı tut", command=self.save_set).pack(side=tk.LEFT, padx=5) #

        self.notebook = ttk.Notebook(self.main_frame)
        self.notebook.pack(fill=tk.BOTH, expand=True, pady=5)
        self.add_tab()

    def add_tab(self):
        if len(self.tabs) >= 5:
            messagebox.showerror("yanlışlık", "En fazla 5 sekme sınırına ulaşıldı.") #
            return

        entity_window = tk.Toplevel(self.root)
        entity_window.title("Sekmeye Varlık Ata") #
        entity_window.geometry("300x150")
        ttk.Label(entity_window, text="Varlık Adını Girin:").pack(pady=5) #
        entity_var = tk.StringVar()
        ttk.Entry(entity_window, textvariable=entity_var).pack(pady=5)

        def confirm_entity():
            entity = entity_var.get().strip()
            if not entity:
                messagebox.showerror("yanlışlıkışlıkışlık", "bir varlık adı girin.") #
                return
            tab_id = str(uuid4())
            tab_name = f"Sekme {len(self.tabs) + 1} ({entity})" #
            tab_frame = ttk.Frame(self.notebook)
            self.notebook.add(tab_frame, text=tab_name)
            self.tabs[tab_id] = {"name": tab_name, "entity": entity}
            self.sets[tab_id] = {}
            entity_window.destroy()
            self.canvas.configure(scrollregion=self.canvas.bbox("all"))

        ttk.Button(entity_window, text="Onayla", command=confirm_entity).pack(pady=5) #

    def add_set(self):
        current_tab = self.notebook.select()
        if not current_tab:
            messagebox.showerror("yanlışlıkışlıkışlık", "Sekme seçilmedi.") #
            return
        tab_id = list(self.tabs.keys())[self.notebook.index(current_tab)]

        if len(self.sets[tab_id]) >= 5:
            messagebox.showerror("yanlışlık", "Sekme başına en fazla 5 toplam sınırına ulaşıldı.") #
            return

        set_type_window = tk.Toplevel(self.root)
        set_type_window.title("Yeni Toplam Yapılandır") #
        set_type_window.geometry("300x200")
        ttk.Label(set_type_window, text="Toplam Türünü Seçin:").pack(pady=5) #
        set_type_var = tk.StringVar()
        set_type_combobox = ttk.Combobox(set_type_window, textvariable=set_type_var, 
                                         values=[t for t in self.valid_set_types if t not in self.sets[tab_id]], 
                                         state="readonly")
        set_type_combobox.pack(pady=5)
        ttk.Label(set_type_window, text="Toplam biçimi Seçin:").pack(pady=5) #
        mode_var = tk.StringVar(value="ağırlık") #
        ttk.Radiobutton(set_type_window, text="Ağırlık Tabanlı", variable=mode_var, value="ağırlık").pack(pady=2) #
        ttk.Radiobutton(set_type_window, text="Sıra Tabanlı", variable=mode_var, value="sıra").pack(pady=2) #

        def confirm_set_type():
            set_type = set_type_var.get()
            mode = mode_var.get()
            if not set_type:
                messagebox.showerror("yanlışlık", "bir toplam türü seçin.") #
                return
            set_frame = ttk.LabelFrame(self.notebook.nametowidget(current_tab), text=f"{set_type} Toplamı ({mode.capitalize()})") #
            set_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            tree = ttk.Treeview(set_frame, columns=("Chain", mode.capitalize()), show="headings")
            tree.heading("Chain", text="Ters törelmelik Bağma") #
            tree.heading(mode.capitalize(), text=mode.capitalize())
            tree.column("Chain", width=600)
            tree.column(mode.capitalize(), width=100)
            tree.pack(fill=tk.BOTH, expand=True)

            tree.bind("<Double-1>", lambda event: self.on_tree_edit(event, tree, set_type, mode, tab_id))
            tree.insert("", "end", values=("", "0" if mode == "sıra" else "0.0")) #
            ttk.Button(set_frame, text="dizgeye TAB Ekle", #
                       command=lambda: tree.insert("", "end", values=("", "0" if mode == "sıra" else "0.0"))).pack(pady=5) #

            self.sets[tab_id][set_type] = {"tree": tree, "mode": mode}
            set_type_window.destroy()
            self.canvas.configure(scrollregion=self.canvas.bbox("all"))

        ttk.Button(set_type_window, text="Onayla", command=confirm_set_type).pack(pady=10) #

    def validate_chain(self, chain, set_type, mode, tab_id, existing_ranks=None):
        try:
            pattern = r"^(Etkilenmeyen|Uygulayan|Tekrarlayan|Onaylamayan|Onaylayan)\s*\[(.*?)\s*\((.*?)\)(?:,\s*(?:Uyguraçları|Gösterimler)\s*\((.*?)\s*\((.*?)\)\))?\]-Gösterimler\s*\[(.*?)\s*\((.*?)\)\]-töreli Değerler\s*\[(.*?)\]-töreli anlatım\s*\[(.*?)\s*\((.*?)\)\]-töreli kaynak\s*\[(.*?)\s*\((.*?)\)\](?:\s*Altbilgi: '([^']+)'\s*(\d+)\s*dönüşüm geçirdi: ([^.\n]*))?$" #
            match = re.match(pattern, chain.strip())
            if not match:
                return False, "Geçersiz bağma biçimi." #

            interactor_type, entity, interaction_tag, extra_field, extra_tag, displayment, displayment_tag, values_str, statement, statement_tag, source, source_tag, footnote_entity, num_trans_str, trans_str = match.groups()
            means = extra_field if interactor_type == "Uygulayan" else "" #
            means_tag = extra_tag if interactor_type == "Uygulayan" else "" #
            repeater_displayment = extra_field if interactor_type == "Tekrarlayan" else "" #
            repeater_displayment_tag = extra_tag if interactor_type == "Tekrarlayan" else "" #

            tab_entity = self.tabs[tab_id]["entity"]
            if entity != tab_entity:
                return False, f"Bağma varlığı '{entity}', sekme varlığı '{tab_entity}' ile eşleşmiyor." #
            if interactor_type != set_type:
                return False, f"Bağma etkileşen türü '{interactor_type}', toplam türü '{set_type}' ile eşleşmiyor." #
            if interaction_tag not in self.valid_interaction_tags:
                return False, f"Geçersiz etkileşim belirteçi '{interaction_tag}'.\nŞunlardan biri olmalı: {', '.join(self.valid_interaction_tags)}." #
            if interactor_type == "Uygulayan": #
                if not means_tag:
                    return False, "Uygulayan etkileşim belirteçleri için Uyguraç belirteçi gereklidir." #
                if means_tag not in self.valid_means_tags:
                    return False, f"Geçersiz uyguraç belirteçi '{means_tag}'.\nŞunlardan biri olmalı: {', '.join(self.valid_means_tags)}." #
            if interactor_type == "Tekrarlayan": #
                if not repeater_displayment_tag:
                    return False, "Tekrarlayan etkileşim belirteçleri için Gösterim belirteçi gereklidir." #
                if repeater_displayment_tag not in self.valid_displayment_tags:
                    return False, f"Geçersiz tekrarlayan gösterim belirteçi '{repeater_displayment_tag}'.\nŞunlardan biri olmalı: {', '.join(self.valid_displayment_tags)}." #
            if displayment_tag not in self.valid_displayment_tags:
                return False, f"Geçersiz gösterim belirteçi '{displayment_tag}'.\nŞunlardan biri olmalı: {', '.join(self.valid_displayment_tags)}." #
            if statement_tag not in self.valid_statement_source_pairs:
                return False, f"Geçersiz anlatım belirteçi '{statement_tag}'.\nŞunlardan biri olmalı: {', '.join(self.valid_statement_source_pairs.keys())}." #
            if source_tag not in self.valid_statement_source_pairs.values():
                return False, f"Geçersiz kaynak belirteçi '{source_tag}'.\nŞunlardan biri olmalı: {', '.join(self.valid_statement_source_pairs.values())}." #
            if self.valid_statement_source_pairs.get(statement_tag) != source_tag:
                return False, "Uyumsuz anlatım ve kaynak belirteçleri." #
            value_items = re.findall(r"(\d+)\.\s*(.*?)\s*\((.*?)\)", values_str)
            value_list = [v[1] for v in value_items]
            value_tags = [v[2] for v in value_items]

            if len(value_list) < 1:
                return False, "En az bir değer gereklidir." #
            if len(value_list) != len(value_tags):
                return False, f"Değerler ({len(value_list)}) ve değer belirteçleri ({len(value_tags)}) arasında uyumsuzluk." #
            valid_values = self.valid_statement_value_pairs.get(statement_tag, {'values': [], 'required': None})['values']
            required_value = self.valid_statement_value_pairs.get(statement_tag, {'values': [], 'required': None})['required']
            for v in value_tags:
                if v not in valid_values:
                    return False, f"'{statement_tag}' anlatım belirteçi için geçersiz değer belirteçi '{v}'.\nŞunlardan biri olmalı: {', '.join(valid_values)}." #
            if required_value and required_value not in value_tags:
                return False, f"'{statement_tag}' anlatım belirteçi için gerekli değer belirteçi '{required_value}' eksik." #
            statement_words = statement.split()
            assigned_words = set(value_list)
            parts_list = [w for w in statement_words if w not in assigned_words]
            limits_list = []
            if not parts_list:
                return False, "En az bir gerekli Kesım gereklidir." #
            components = [(v, "Değer") for v in value_list] + [(p, "Gerekli Kesım") for p in parts_list] + [(l, "Sınırlama") for l in limits_list] #
            component_positions = []
            for comp, comp_type in components:
                start = statement.find(comp)
                if start == -1:
                    return False, f"{comp_type} '{comp}' anlatımda bulunamadı." #
                component_positions.append((start, start + len(comp), comp, comp_type))
            component_positions.sort()

            current_pos = 0
            for start, end, comp, comp_type in component_positions:
                if start < current_pos:
                    return False, f"{comp_type} '{comp}' {start} yerinde önceki bileşenlerle çakışıyor." #
                current_pos = max(current_pos, end)

            if footnote_entity:
                if interactor_type == "Tekrarlayan": #
                    return False, "Tekrarlayanlar dönüşüm geçiremez." #
                if footnote_entity != entity:
                    return False, "Altbilgi varlığı bağma varlığı ile eşleşmiyor." #
                if not trans_str:
                    return False, "Altbilgi dönüşüm yolu boş." #
                num_trans = int(num_trans_str)
                trans_path = [t.strip() for t in trans_str.strip().split("->")]
                if len(trans_path) != num_trans + 1:
                    return False, f"Altbilgi dönüşüm sayısı uyuşmazlığı: {num_trans + 1} belirteç bekleniyordu, {len(trans_path)} bulundu." #
                for t in trans_path:
                    if t not in self.valid_interaction_tags:
                        return False, f"Altbilgide geçersiz etkileşim belirteçi: '{t}'." #
                forward_path = trans_path[::-1]
                if forward_path[0] != interaction_tag:
                    return False, f"Altbilgi dönüşüm yolu başlangıç etkileşim belirteçi '{interaction_tag}' ile başlamıyor, '{forward_path[0]}' bulundu." #
                for i in range(num_trans):
                    from_tag = forward_path[i]
                    to_tag = forward_path[i + 1]
                    possible_next = self.forward_conversion_rules.get(from_tag, []) + self.forward_transformation_rules.get(from_tag, [])
                    if to_tag not in possible_next:
                        return False, f"Altbilgide geçersiz dönüşüm: {from_tag}->{to_tag}.\nOlası sonraki belirteçler: {', '.join(possible_next)}." #
            return True, ""
        except Exception as e:
            return False, f"Doğrulama yanlışlığı: {str(e)}" #

    def get_statement_components(self, chain):
        try:
            chain_without_footnote = re.sub(r"\s*Altbilgi:.*$", "", chain) #
            statement_match = re.search(r"töreli anlatım\s*\[(.*?)\s*\(\w+\)\]", chain_without_footnote) #
            values_match = re.search(r"töreli Değerler\s*\[(.*?)\]", chain_without_footnote) #
            if not statement_match or not values_match:
                return [], [], []

            statement = statement_match.group(1)
            value_items = re.findall(r"\d+\.\s*(.*?)\s*\(\w+\)", values_match.group(1))
            value_list = [v for v in value_items]
            statement_words = statement.split()
            parts_list = [w for w in statement_words if w not in value_list]
            limits_list = []

            return value_list, parts_list, limits_list
        except Exception as e:
            return [], [], []

    def apply_statement_colors(self, text_widget, statement, value_list, parts_list, limits_list):
        try:
            text_widget.tag_remove("values", "1.0", tk.END)
            text_widget.tag_remove("parts", "1.0", tk.END)
            text_widget.tag_remove("limits", "1.0", tk.END)

            components = [(v, "values") for v in value_list] + [(p, "parts") for p in parts_list] + [(l, "limits") for l in limits_list]
            component_positions = []
            for comp, tag in components:
                start = statement.find(comp)
                if start != -1:
                    component_positions.append((start, start + len(comp), comp, tag))
            component_positions.sort()

            for start, end, comp, tag in component_positions:
                text_widget.tag_add(tag, f"1.0+{start}c", f"1.0+{end}c")
            return component_positions
        except Exception as e:
            return []

    def on_tree_edit(self, event, tree, set_type, mode, tab_id):
        item = tree.identify_row(event.y)
        column = tree.identify_column(event.x)
        if not item or not column:
            return
        col_index = int(column[1:]) - 1
        if col_index not in [0, 1]:
            return

        x, y, width, height = tree.bbox(item, column)
        if col_index == 0:
            entry = tk.Text(tree, height=2, width=70)
        else:
            entry = ttk.Entry(tree)
        entry.place(x=x, y=y, width=width, height=height)
        current_value = tree.item(item, "values")[col_index]
        entry.insert("1.0" if col_index == 0 else 0, current_value)

        def save_edit(event=None):
            new_value = entry.get("1.0", tk.END).strip() if col_index == 0 else entry.get()
            values = list(tree.item(item, "values"))
            if col_index == 1:
                if mode == "sıra": #
                    try:
                        rank = int(new_value)
                        if rank < 1:
                            messagebox.showerror("yanlışlık", "Sıra 1+ sayı olmalıdır.") #
                            entry.destroy()
                            return
                        existing_ranks = [int(tree.item(i, "values")[1]) for i in tree.get_children() if i != item and tree.item(i, "values")[1]]
                        if rank in existing_ranks:
                            messagebox.showerror("yanlışlık", f"{rank} sırası bu toplamda zaten kullanılıyor.") #
                            entry.destroy()
                            return
                    except ValueError:
                        messagebox.showerror("yanlışlık", "Sıra geçerli bir tam sayı olmalıdır.") #
                        entry.destroy()
                        return
                else:
                    try:
                        weight = float(new_value)
                        if weight < 0:
                            messagebox.showerror("yanlışlıkışlık", "Ağırlık 1- olmayan bir sayı olmalıdır.") #
                            entry.destroy()
                            return
                    except ValueError:
                        messagebox.showerror("yanlışlıkışlık", "Ağırlık geçerli bir sayı olmalıdır.") #
                        entry.destroy()
                        return
            values[col_index] = new_value
            tree.item(item, values=values)
            if col_index == 0 and new_value:
                value_list, parts_list, limits_list = self.get_statement_components(new_value)
                chain_text = tk.Text(tree, height=2, width=70)
                chain_text.insert("1.0", new_value)
                chain_text.tag_configure("values", foreground="red")
                chain_text.tag_configure("parts", foreground="blue")
                chain_text.tag_configure("limits", foreground="green")
                statement_match = re.search(r"töreli anlatım\s*\[(.*?)\s*\(\w+\)\]", new_value) #
                if statement_match:
                    statement = statement_match.group(1)
                    self.apply_statement_colors(chain_text, statement, value_list, parts_list, limits_list)
                chain_text.configure(state="disabled")
                tree.item(item, values=(chain_text.get("1.0", tk.END).strip(), values[1]))
            entry.destroy()

        entry.bind("<Return>", save_edit)
        entry.bind("<FocusOut>", save_edit)
        entry.focus_set()

    def validate_tab(self):
        current_tab = self.notebook.select()
        if not current_tab:
            messagebox.showerror("yanlışlık", "Sekme seçilmedi.") #
            return
        tab_id = list(self.tabs.keys())[self.notebook.index(current_tab)]
        if not self.tabs[tab_id]["entity"]:
            messagebox.showerror("yanlışlık", "Bu sekmeye atanmış varlık yok.") #
            return

        set_types = list(self.sets[tab_id].keys())
        if not set_types:
            messagebox.showerror("yanlışlık", "olan sekmede toplam yok.") #
            return

        errors = []
        source_tag_errors = []
        for set_type in set_types:
            tree = self.sets[tab_id][set_type]["tree"]
            mode = self.sets[tab_id][set_type]["mode"]
            set_errors = []
            ranks = []
            source_tags = []
            for item in tree.get_children():
                chain, weight = tree.item(item, "values")
                if not chain:
                    set_errors.append(f"çuzge {item}: Boş bağma.") #
                    continue
                source_match = re.search(r"töreli kaynak\s*\[(.*?)\s*\((\w+)\)\]", chain) #
                if source_match:
                    source_tag = source_match.group(2)
                    source_tags.append(source_tag)
                valid, error = self.validate_chain(chain, set_type, mode, tab_id, ranks)
                if not valid:
                    set_errors.append(f"çuzge {item}: {error}") #
                    continue
                try:
                    value = int(weight) if mode == "sıra" else float(weight) #
                    if mode == "sıra": #
                        if value in ranks:
                            set_errors.append(f"çuzge {item}: Tekrar eden sıra {value}.") #
                        ranks.append(value)
                except ValueError:
                    set_errors.append(f"çuzge {item}: Geçersiz {mode} '{weight}'.") #
                    continue
            if set_errors:
                errors.extend([f"{set_type} Toplamı: {e}" for e in set_errors]) #
            if source_tags and len(set(source_tags)) > 1:
                source_tag_errors.append(f"{set_type} Toplamı: Tüm bağmalar özdeş kaynak belirteçini paylaşmalıdır. Bulunanlar: {', '.join(set(source_tags))}.") #

        all_errors = errors + source_tag_errors
        if all_errors:
            messagebox.showerror("Doğrulama yanlışlıkları", "\n".join(all_errors)) #
        else:
            messagebox.showinfo("Başarılı", "Sekmedeki tüm toplamlar geçerli.") #

    def save_set(self):
        current_tab = self.notebook.select()
        if not current_tab:
            messagebox.showerror("yanlışlık", "Sekme seçilmedi.") #
            return
        tab_id = list(self.tabs.keys())[self.notebook.index(current_tab)]
        if not self.tabs[tab_id]["entity"]:
            messagebox.showerror("yanlışlık", "Bu sekmeye atanmış varlık yok.") #
            return

        set_types = list(self.sets[tab_id].keys())
        if not set_types:
            messagebox.showerror("yanlışlık", "olan sekmede toplam yok.") #
            return

        save_window = tk.Toplevel(self.root)
        save_window.title("tutulanılıcak Toplamı Seçin") #
        save_window.geometry("300x150")
        ttk.Label(save_window, text="Toplam Türünü Seçin:").pack(pady=5) #
        set_type_var = tk.StringVar()
        ttk.Combobox(save_window, textvariable=set_type_var, values=set_types, state="readonly").pack(pady=5)

        def confirm_save():
            set_type = set_type_var.get()
            if not set_type:
                messagebox.showerror("yanlışlık", "bir toplam türü seçin.") #
                return
            tree = self.sets[tab_id][set_type]["tree"]
            mode = self.sets[tab_id][set_type]["mode"]
            set_data = []
            errors = []
            ranks = []

            for item in tree.get_children():
                chain, weight = tree.item(item, "values")
                if not chain:
                    errors.append(f"çuzge {item}: Boş bağma.") #
                    continue
                valid, error = self.validate_chain(chain, set_type, mode, tab_id, ranks)
                if not valid:
                    errors.append(f"çuzge {item}: {error}") #
                    continue
                try:
                    value = int(weight) if mode == "sıra" else float(weight) #
                    if mode == "sıra": #
                        if value in ranks:
                            errors.append(f"çuzge {item}: Tekrar eden sıra {value}.") #
                        ranks.append(value)
                    set_data.append({"chain": chain, mode: value})
                except ValueError:
                    errors.append(f"çuzge {item}: Geçersiz {mode} '{weight}'.") #
                    continue

            if errors:
                messagebox.showerror("tutma yanlışlıkları", "\n".join(errors)) #
            else:
                try:
                    with open(f"{set_type}_toplami_{tab_id}.json", "w") as f: #
                        json.dump(set_data, f, indent=2)
                    messagebox.showinfo("Başarılı", f"{set_type} Toplamı {set_type}_toplami_{tab_id}.json tutuldu") #
                except Exception as e:
                    messagebox.showerror("yanlışlık", f"Toplam tutulanılamadı: {str(e)}") #
            save_window.destroy()

        ttk.Button(save_window, text="Onayla", command=confirm_save).pack(pady=5) #

if __name__ == "__main__":
    root = tk.Tk()
    app = TersTorenmelikBagmaToplamiOnaylayicisi(root)
    root.mainloop()