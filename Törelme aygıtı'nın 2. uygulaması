import tkinter as tk
from tkinter import ttk, messagebox
import re
import uuid

class MoralithicChainGeneratorMode2:
    def __init__(self, root):
        self.root = root
        self.root.title("törelmelik bağma kurucusu - uygulama 2")
        self.valid_statement_source_pairs = {
            'AT31': 'KN30', 'AT32': 'KN31', 'AT33': 'KN32', 'AT34': 'KN33', 'AT43': 'KN42',
            'AT44': 'KN43', 'AT45': 'KN44', 'AT46': 'KN45', 'AT47': 'KN46', 'AT48': 'KN47',
            'AT49': 'KN48', 'AT50': 'KN49', 'AT52': 'KN51', 'AT54': 'KN53', 'AT56': 'KN55',
            'AT58': 'KN57', 'AT59': 'KN58', 'AT60': 'KN59', 'AT61': 'KN60', 'AT62': 'KN61',
            'AT63': 'KN62', 'AT64': 'KN63', 'AT65': 'KN64', 'AT66': 'KN65', 'AT67': 'KN66',
            'AT68': 'KN67', 'AT69': 'KN68', 'AT70': 'KN69', 'AT71': 'KN70', 'AT72': 'KN71',
            'AT73': 'KN72', 'AT74': 'KN73'
        }
        self.valid_source_statement_pairs = {v: k for k, v in self.valid_statement_source_pairs.items()}
        self.valid_statement_value_pairs = {
            'AT31': {'values': ['DR31'], 'required': 'DR31'},
            'AT32': {'values': ['DR31', 'DR32'], 'required': 'DR32'},
            'AT33': {'values': ['DR33'], 'required': 'DR33'},
            'AT34': {'values': ['DR31', 'DR32', 'DR33', 'DR34'], 'required': 'DR34'},
            'AT43': {'values': ['DR43'], 'required': 'DR43'},
            'AT44': {'values': ['DR43', 'DR44'], 'required': 'DR44'},
            'AT45': {'values': ['DR45'], 'required': 'DR45'},
            'AT46': {'values': ['DR43', 'DR44', 'DR45', 'DR46'], 'required': 'DR46'},
            'AT47': {'values': ['DR47'], 'required': 'DR47'},
            'AT48': {'values': ['DR47', 'DR48'], 'required': 'DR48'},
            'AT49': {'values': ['DR47', 'DR48', 'DR49'], 'required': 'DR49'},
            'AT50': {'values': ['DR47', 'DR48', 'DR49', 'DR50'], 'required': 'DR50'},
            'AT52': {'values': ['DR52'], 'required': 'DR52'},
            'AT54': {'values': ['DR54'], 'required': 'DR54'},
            'AT56': {'values': ['DR56'], 'required': 'DR56'},
            'AT58': {'values': ['DR58'], 'required': 'DR58'},
            'AT59': {'values': ['DR59'], 'required': 'DR59'},
            'AT60': {'values': ['DR59', 'DR60'], 'required': 'DR60'},
            'AT61': {'values': ['DR61'], 'required': 'DR61'},
            'AT62': {'values': ['DR59', 'DR60', 'DR61', 'DR62'], 'required': 'DR62'},
            'AT63': {'values': ['DR63'], 'required': 'DR63'},
            'AT64': {'values': ['DR63', 'DR64'], 'required': 'DR64'},
            'AT65': {'values': ['DR65'], 'required': 'DR65'},
            'AT66': {'values': ['DR63', 'DR64', 'DR65', 'DR66'], 'required': 'DR66'},
            'AT67': {'values': ['DR67'], 'required': 'DR67'},
            'AT68': {'values': ['DR67', 'DR68'], 'required': 'DR68'},
            'AT69': {'values': ['DR69'], 'required': 'DR69'},
            'AT70': {'values': ['DR67', 'DR68', 'DR69', 'DR70'], 'required': 'DR70'},
            'AT71': {'values': ['DR71'], 'required': 'DR71'},
            'AT72': {'values': ['DR71', 'DR72'], 'required': 'DR72'},
            'AT73': {'values': ['DR73'], 'required': 'DR73'},
            'AT74': {'values': ['DR71', 'DR72', 'DR73', 'DR74'], 'required': 'DR74'}
        }
        self.valid_ni_tags = ['EM04', 'EM05', 'EM06', 'EM07']
        self.valid_ef_tags = [f"UY{i}" for i in range(32, 64)]
        self.valid_rp_tags = ['TK04', 'TK05', 'TK06', 'TK07']
        self.valid_re_tags = [f"OM{i:02d}" for i in range(8, 16)]
        self.valid_ac_tags = [f"OL{i:02d}" for i in range(8, 16)]
        self.valid_means_tags = ["UR02", "UR03"]
        self.valid_displayment_tags = ["GM02", "GM03"]
        self.valid_statement_tags = list(self.valid_statement_source_pairs.keys())
        self.valid_source_tags = list(self.valid_source_statement_pairs.keys())
        self.valid_value_tags = sorted(set(sum([d['values'] for d in self.valid_statement_value_pairs.values()], [])))
        self.required_values = ['DR31', 'DR33', 'DR43', 'DR45', 'DR47', 'DR49', 'DR59', 'DR61', 'DR63', 'DR65', 'DR67', 'DR69', 'DR71', 'DR73']
        self.required_ini_tags = ['EM04', 'EM06', 'UY32', 'UY34', 'UY36', 'UY38', 'UY40', 'UY42', 'UY44', 'UY46', 'UY48', 'UY50', 'UY52', 'UY54', 'UY56', 'UY58', 'UY60', 'UY62', 'TK04', 'TK06', 'OM08', 'OM10', 'OM12', 'OM14', 'OL08', 'OL10', 'OL12', 'OL14']
        self.ac_compat = {
            'OL12': ['UY36', 'UY38'],
            'OL13': ['UY37', 'UY39'],
            'OL14': ['UY44', 'UY46', 'TK06'],
            'OL15': ['UY45', 'UY47', 'TK07']
        }
        self.function_source_tags = ['KN51', 'KN53', 'KN55', 'KN57', 'KN66', 'KN67', 'KN68', 'KN69', 'KN70', 'KN71', 'KN72', 'KN73']
        self.process_source_tags = ['KN58', 'KN59', 'KN60', 'KN61', 'KN62', 'KN63', 'KN64', 'KN65']
        self.function_statement_tags = ['AT52', 'AT54', 'AT56', 'AT58', 'AT67', 'AT68', 'AT69', 'AT70', 'AT71', 'AT72', 'AT73', 'AT74']
        self.process_statement_tags = ['AT59', 'AT60', 'AT61', 'AT62', 'AT63', 'AT64', 'AT65', 'AT66']
        self.value_items = []
        self.non_interactor_items = []
        self.enforcer_items = []
        self.repeater_items = []
        self.rejecter_items = []
        self.accepter_items = []
        self.interactors = []
        self.chain_text = ""
        self.conversion_rules = {
            'OL08': ['OM08', 'OM12'], 'OL09': ['OM09', 'OM13'], 'OL10': ['OM10', 'OM14'], 'OL11': ['OM11', 'OM15'],
            'OL12': ['OM08', 'OM12'], 'OL13': ['OM09', 'OM13'], 'OL14': ['OM10', 'OM14'], 'OL15': ['OM11', 'OM15'],
            'OM08': ['OL08', 'OL12'], 'OM09': ['OL09', 'OL13'], 'OM10': ['OL10', 'OL14'], 'OM11': ['OL11', 'OL15'],
            'OM12': ['OL08', 'OL12'], 'OM13': ['OL09', 'OL13'], 'OM14': ['OL10', 'OL14'], 'OM15': ['OL11', 'OL15']
        }
        self.transformation_rules = {
            'EM04': ['EM06'], 'EM05': ['EM07'], 'EM06': ['EM04'], 'EM07': ['EM05'],
            'UY32': ['UY34', 'UY36', 'UY38'], 'UY33': ['UY35', 'UY37', 'UY39'], 'UY34': ['UY32', 'UY36', 'UY38'],
            'UY35': ['UY33', 'UY37', 'UY39'], 'UY36': ['UY32', 'UY34', 'UY38'], 'UY37': ['UY33', 'UY35', 'UY39'],
            'UY38': ['UY32', 'UY34', 'UY36'], 'UY39': ['UY33', 'UY35', 'UY37'], 'UY40': ['UY42', 'UY44', 'UY46'],
            'UY41': ['UY43', 'UY45', 'UY47'], 'UY42': ['UY40', 'UY44', 'UY46'], 'UY43': ['UY41', 'UY45', 'UY47'],
            'UY44': ['UY40', 'UY42', 'UY46'], 'UY45': ['UY41', 'UY43', 'UY47'], 'UY46': ['UY40', 'UY42', 'UY44'],
            'UY47': ['UY41', 'UY43', 'UY45'], 'UY48': ['UY50', 'UY52', 'UY54'], 'UY49': ['UY51', 'UY53', 'UY55'],
            'UY50': ['UY48', 'UY52', 'UY54'], 'UY51': ['UY49', 'UY53', 'UY55'], 'UY52': ['UY48', 'UY50', 'UY54'],
            'UY53': ['UY49', 'UY51', 'UY55'], 'UY54': ['UY48', 'UY50', 'UY52'], 'UY55': ['UY49', 'UY51', 'UY53'],
            'UY56': ['UY58', 'UY60', 'UY62'], 'UY57': ['UY59', 'UY61', 'UY63'], 'UY58': ['UY56', 'UY60', 'UY62'],
            'UY59': ['UY57', 'UY61', 'UY63'], 'UY60': ['UY56', 'UY58', 'UY62'], 'UY61': ['UY57', 'UY59', 'UY63'],
            'UY62': ['UY56', 'UY58', 'UY60'], 'UY63': ['UY57', 'UY59', 'UY61'],
            'OM08': ['OM12'], 'OM09': ['OM13'], 'OM10': ['OM14'], 'OM11': ['OM15'],
            'OM12': ['OM08'], 'OM13': ['OM09'], 'OM14': ['OM10'], 'OM15': ['OM11'],
            'OL08': ['OL12'], 'OL09': ['OL13'], 'OL10': ['OL14'], 'OL11': ['OL15'],
            'OL12': ['OL08'], 'OL13': ['OL09'], 'OL14': ['OL10'], 'OL15': ['OL11'],
            'TK04': [], 'TK05': [], 'TK06': [], 'TK07': []
        }
        self.valid_interaction_tags = (
            self.valid_ni_tags + self.valid_ef_tags + self.valid_rp_tags + self.valid_re_tags + self.valid_ac_tags
        )
        self.setup_gui()

    def setup_gui(self):
        canvas_frame = ttk.Frame(self.root)
        canvas_frame.pack(fill=tk.BOTH, expand=True)
        self.canvas = tk.Canvas(canvas_frame)
        v_scrollbar = ttk.Scrollbar(canvas_frame, orient=tk.VERTICAL, command=self.canvas.yview)
        h_scrollbar = ttk.Scrollbar(canvas_frame, orient=tk.HORIZONTAL, command=self.canvas.xview)
        self.main_frame = ttk.Frame(self.canvas)
        self.canvas.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
        self.canvas.create_window((0, 0), window=self.main_frame, anchor="nw")
        v_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        h_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)
        self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=10, pady=10)

        self.main_frame.bind("<Configure>", self._update_scrollregion)

        self.canvas.bind_all("<MouseWheel>", self._on_mousewheel)
        self.canvas.bind_all("<Button-4>", self._on_mousewheel)
        self.canvas.bind_all("<Button-5>", self._on_mousewheel)

        # Moral Source
        ttk.Label(self.main_frame, text="1. araştırdığınız töreli anlatımın töreli kaynağı nedir?").pack(anchor=tk.W)
        self.source_text = ttk.Entry(self.main_frame, width=50)
        self.source_text.pack(anchor=tk.W, pady=2)
        ttk.Label(self.main_frame, text="kaynak törelmelik belirteç:").pack(anchor=tk.W)
        self.source_tag = ttk.Combobox(self.main_frame, values=self.valid_source_tags, state="readonly")
        self.source_tag.pack(anchor=tk.W, pady=5)
        self.source_tag.bind("<<ComboboxSelected>>", self.update_source_extra)

        self.extra_source_frame = ttk.Frame(self.main_frame)
        self.extra_source_label = ttk.Label(self.extra_source_frame, text="")
        self.extra_source_label.pack(anchor=tk.W)
        self.extra_source_entry = ttk.Entry(self.extra_source_frame, width=50)
        self.extra_source_entry.pack(anchor=tk.W, pady=2)
        self.extra_source_frame.pack_forget()

        # Moral Statement
        ttk.Label(self.main_frame, text="2. araştırdığınız töreli anlatım nedir?").pack(anchor=tk.W)
        self.statement_text = tk.Text(self.main_frame, height=3, width=50)
        self.statement_text.pack(anchor=tk.W, pady=2)
        self.statement_text.tag_configure("values", foreground="red")
        self.statement_text.tag_configure("parts", foreground="blue")
        self.statement_text.tag_configure("limits", foreground="green")
        ttk.Label(self.main_frame, text="töreli anlatım törelmelik belirteç:").pack(anchor=tk.W)
        self.statement_tag = ttk.Combobox(self.main_frame, values=self.valid_statement_tags, state="readonly")
        self.statement_tag.pack(anchor=tk.W, pady=5)
        self.statement_tag.bind("<<ComboboxSelected>>", self.update_statement_extra)

        self.extra_statement_frame = ttk.Frame(self.main_frame)
        self.extra_statement_label = ttk.Label(self.extra_statement_frame, text="")
        self.extra_statement_label.pack(anchor=tk.W)
        self.extra_statement_entry = ttk.Entry(self.extra_statement_frame, width=50)
        self.extra_statement_entry.pack(anchor=tk.W, pady=2)
        self.extra_statement_frame.pack_forget()

        # Values
        ttk.Label(self.main_frame, text="3. araştırdığınız töreli anlatımın töreli değerleri nedir? ( , ile ayırt)").pack(anchor=tk.W)
        self.values_input = ttk.Entry(self.main_frame, width=50)
        self.values_input.pack(anchor=tk.W, pady=2)
        ttk.Button(self.main_frame, text="töreli değerleri ile onların törelmelik belirtecini ekle ", command=self.add_value_items).pack(anchor=tk.W, pady=5)
        self.values_frame = ttk.Frame(self.main_frame)
        self.values_frame.pack(anchor=tk.W, pady=2)
        ttk.Label(self.main_frame, text="töreli değerler (görselleştirme):").pack(anchor=tk.W)
        self.values_text = tk.Text(self.main_frame, height=3, width=50)
        self.values_text.pack(anchor=tk.W, pady=2)

        # Necessary Parts
        ttk.Label(self.main_frame, text="4. gerekli Kesımlerı ( , ile ayırt):").pack(anchor=tk.W)
        self.parts_input = ttk.Entry(self.main_frame, width=50)
        self.parts_input.pack(anchor=tk.W, pady=2)
        ttk.Button(self.main_frame, text="gerekli Kesımlerı ekle", command=self.add_parts).pack(anchor=tk.W, pady=5)
        self.parts_frame = ttk.Frame(self.main_frame)
        self.parts_frame.pack(anchor=tk.W, pady=2)
        ttk.Label(self.main_frame, text="gerekli Kesımlerı (görselleştirme):").pack(anchor=tk.W)
        self.parts_text = tk.Text(self.main_frame, height=3, width=50)
        self.parts_text.pack(anchor=tk.W, pady=2)

        # Limitations
        ttk.Label(self.main_frame, text="5. sınırlamalar (eğer varsa, bükük nokta ile ayırt):").pack(anchor=tk.W)
        self.limits_input = ttk.Entry(self.main_frame, width=50)
        self.limits_input.pack(anchor=tk.W, pady=2)
        ttk.Button(self.main_frame, text="sınırlamalar ekle", command=self.add_limits).pack(anchor=tk.W, pady=5)
        self.limits_frame = ttk.Frame(self.main_frame)
        self.limits_frame.pack(anchor=tk.W, pady=2)
        ttk.Label(self.main_frame, text="sınırlamalar (görselleştirme):").pack(anchor=tk.W)
        self.limits_text = tk.Text(self.main_frame, height=3, width=50)
        self.limits_text.pack(anchor=tk.W, pady=5)

        # Displayments
        ttk.Label(self.main_frame, text="6. hangi gösterim ile araştırdığınız töreli anlatım kaynaklandı?").pack(anchor=tk.W)
        self.displayment_input = ttk.Entry(self.main_frame, width=50)
        self.displayment_input.pack(anchor=tk.W, pady=2)
        ttk.Label(self.main_frame, text="gösterim törelmelik belirteç:").pack(anchor=tk.W)
        self.displayment_tag = ttk.Combobox(self.main_frame, values=self.valid_displayment_tags, state="readonly")
        self.displayment_tag.pack(anchor=tk.W, pady=5)

        self.values_text.bind("<KeyRelease>", self.update_statement_colors)
        self.parts_text.bind("<KeyRelease>", self.update_statement_colors)
        self.limits_text.bind("<KeyRelease>", self.update_statement_colors)

        # Interactors
        ttk.Label(self.main_frame, text="7. etkilenenler (eğer varsa):").pack(anchor=tk.W, pady=(10, 0))

        # Non-interactors
        ni_frame = ttk.LabelFrame(self.main_frame, text="etkilenmeyenler")
        ni_frame.pack(anchor=tk.W, pady=5, padx=5, fill=tk.X)
        ttk.Button(ni_frame, text="etkilenmeyen ekle", command=self.add_non_interactor).pack(anchor=tk.W, pady=2)
        self.non_interactors_container = ttk.Frame(ni_frame)
        self.non_interactors_container.pack(anchor=tk.W, pady=2)

        # Enforcers
        ef_frame = ttk.LabelFrame(self.main_frame, text="uygulayanlar")
        ef_frame.pack(anchor=tk.W, pady=5, padx=5, fill=tk.X)
        ttk.Button(ef_frame, text="uygulayan ekle", command=self.add_enforcer).pack(anchor=tk.W, pady=2)
        self.enforcers_container = ttk.Frame(ef_frame)
        self.enforcers_container.pack(anchor=tk.W, pady=2)

        # Repeaters
        rp_frame = ttk.LabelFrame(self.main_frame, text="tekrarlayanlar")
        rp_frame.pack(anchor=tk.W, pady=5, padx=5, fill=tk.X)
        ttk.Button(rp_frame, text="tekrarlayan ekle", command=self.add_repeater).pack(anchor=tk.W, pady=2)
        self.repeaters_container = ttk.Frame(rp_frame)
        self.repeaters_container.pack(anchor=tk.W, pady=2)

        # Rejecters
        re_frame = ttk.LabelFrame(self.main_frame, text="onaylamayanlar")
        re_frame.pack(anchor=tk.W, pady=5, padx=5, fill=tk.X)
        ttk.Button(re_frame, text="onaylamayan ekle", command=self.add_rejecter).pack(anchor=tk.W, pady=2)
        self.rejecters_container = ttk.Frame(re_frame)
        self.rejecters_container.pack(anchor=tk.W, pady=2)

        # Accepters
        ac_frame = ttk.LabelFrame(self.main_frame, text="onaylayanlar")
        ac_frame.pack(anchor=tk.W, pady=5, padx=5, fill=tk.X)
        ttk.Button(ac_frame, text="onaylayan ekle", command=self.add_accepter).pack(anchor=tk.W, pady=2)
        self.accepters_container = ttk.Frame(ac_frame)
        self.accepters_container.pack(anchor=tk.W, pady=2)

        ttk.Button(self.main_frame, text="törelmelik bağma kur", command=self.generate_chain).pack(anchor=tk.W, pady=10)
        self.result_text = tk.Text(self.main_frame, height=10, width=80)
        self.result_text.pack(anchor=tk.W, pady=5)
        self.result_text.tag_configure("values", foreground="red")
        self.result_text.tag_configure("parts", foreground="blue")
        self.result_text.tag_configure("limits", foreground="green")
        self.result_text.tag_configure("bold", font=("TkDefaultFont", 9, "bold"))

        button_frame = ttk.Frame(self.main_frame)
        button_frame.pack(anchor=tk.W, pady=5, fill=tk.X)
        ttk.Button(button_frame, text="törelmelik bağmayı al", command=self.copy_chain).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="altbilgi ekle", command=self.setup_footnotes).pack(side=tk.LEFT, padx=5)

        self.footnote_container = ttk.Frame(self.main_frame)
        self.footnote_container.pack(anchor=tk.W, pady=5, fill=tk.X)

    def update_source_extra(self, event=None):
        source_tag = self.source_tag.get()
        if source_tag in self.function_source_tags:
            self.extra_source_label.config(text="araştırdığınız töreli anlatımın kaynaklayan töreli yetkili kaynağın töreli işlevi nedir?")
            self.extra_source_frame.pack(anchor=tk.W, pady=5)
        elif source_tag in self.process_source_tags:
            self.extra_source_label.config(text="araştırdığınız töreli anlatımın kaynaklayan töreli yetkisiz kaynağın töreli anlatım üretim işlemi nedir?")
            self.extra_source_frame.pack(anchor=tk.W, pady=5)
        else:
            self.extra_source_frame.pack_forget()

    def update_statement_extra(self, event=None):
        st_tag = self.statement_tag.get()
        if st_tag in self.function_statement_tags:
            self.extra_statement_label.config(text="araştırdığınız töreli anlatım kaynağısının hangi töreli işlevisinden kaynaklandı?")
            self.extra_statement_frame.pack(anchor=tk.W, pady=5)
        elif st_tag in self.process_statement_tags:
            self.extra_statement_label.config(text="araştırdığınız töreli anlatım kaynağısının hangi töreli anlatım üretim işlemisinden kaynaklandı?")
            self.extra_statement_frame.pack(anchor=tk.W, pady=5)
        else:
            self.extra_statement_frame.pack_forget()

    def add_value_items(self):
        try:
            values_str = self.values_input.get().strip()
            if not values_str:
                messagebox.showerror("yanlış sonuç", "değerleri törelmelik belirteçleri eklemeden önce ekleyen.")
                return
            value_list = [v.strip() for v in values_str.split(",") if v.strip()]
            if not value_list:
                messagebox.showerror("yanlış sonuç", "geçerli değerler verilmedi.")
                return

            for widget in self.values_frame.winfo_children():
                widget.destroy()
            self.value_items.clear()

            for i, value in enumerate(value_list, 1):
                frame = ttk.Frame(self.values_frame)
                frame.pack(anchor=tk.W, pady=2)
                ttk.Label(frame, text=f"Value {i}: {value}").pack(side=tk.LEFT)
                tag = ttk.Combobox(frame, values=self.valid_value_tags, state="readonly", width=10)
                tag.pack(side=tk.LEFT, padx=5)
                self.value_items.append((value, tag))

            self.values_text.delete("1.0", tk.END)
            self.values_text.insert("1.0", ", ".join(f"{i}. {v}" for i, v in enumerate(value_list, 1)))
            self.canvas.configure(scrollregion=self.canvas.bbox("all"))
            self.update_statement_colors()
            self.values_input.delete(0, tk.END)
        except Exception as e:
            messagebox.showerror("yanlış sonuç", f"töreli değerler eklenilemedi: {str(e)}")

    def add_parts(self):
        try:
            parts = self.parts_input.get().strip()
            if not parts:
                messagebox.showerror("yanlış sonuç", "gerekli Kesımlerı eklemeden önce verin.")
                return
            parts_list = [p.strip() for p in parts.split(",") if p.strip()]
            if not parts_list:
                messagebox.showerror("yanlış sonuç", "geçerli gerekli Kesımlerı verilmedi.")
                return

            for widget in self.parts_frame.winfo_children():
                widget.destroy()

            for i, part in enumerate(parts_list, 1):
                frame = ttk.Frame(self.parts_frame)
                frame.pack(anchor=tk.W, pady=2)
                ttk.Label(frame, text=f"Part {i}: {part}").pack(side=tk.LEFT)

            self.parts_text.delete("1.0", tk.END)
            self.parts_text.insert("1.0", ", ".join(f"{i}. {p}" for i, p in enumerate(parts_list, 1)))
            self.canvas.configure(scrollregion=self.canvas.bbox("all"))
            self.update_statement_colors()
        except Exception as e:
            messagebox.showerror("yanlış sonuç", f"gerekli Kesımlerı eklenilemedi: {str(e)}")

    def add_limits(self):
        try:
            limits = self.limits_input.get().strip()
            if not limits:
                return

            limits_list = [l.strip() for l in limits.split(",") if l.strip()]
            if not limits_list:
                return

            for widget in self.limits_frame.winfo_children():
                widget.destroy()

            for i, limit in enumerate(limits_list, 1):
                frame = ttk.Frame(self.limits_frame)
                frame.pack(anchor=tk.W, pady=2)
                ttk.Label(frame, text=f"sınırlamalar {i}: {limit}").pack(side=tk.LEFT)

            self.limits_text.delete("1.0", tk.END)
            self.limits_text.insert("1.0", ", ".join(f"{i}. {l}" for i, l in enumerate(limits_list, 1)))
            self.canvas.configure(scrollregion=self.canvas.bbox("all"))
            self.update_statement_colors()
        except Exception as e:
            messagebox.showerror("yanlış sonuç", f"sınırlamalar eklenilemedi: {str(e)}")

    def add_non_interactor(self):
        frame = ttk.Frame(self.non_interactors_container)
        entity = ttk.Entry(frame, width=40)
        entity.pack(side=tk.LEFT, padx=(0, 5))
        tag = ttk.Combobox(frame, values=self.valid_ni_tags, state="readonly", width=10)
        tag.pack(side=tk.LEFT)
        remove_btn = ttk.Button(frame, text="kaldır", command=lambda f=frame: self.remove_item(f, self.non_interactor_items))
        remove_btn.pack(side=tk.LEFT, padx=5)
        frame.pack(anchor=tk.W, pady=1)
        self.non_interactor_items.append({'entity': entity, 'tag': tag})
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))

    def add_enforcer(self):
        ef_main_frame = ttk.Frame(self.enforcers_container)
        entity_label = ttk.Label(ef_main_frame, text="varlık:")
        entity_label.pack(anchor=tk.W)
        entity = ttk.Entry(ef_main_frame, width=50)
        entity.pack(anchor=tk.W)
        tag_label = ttk.Label(ef_main_frame, text="törelmelik belirteç:")
        tag_label.pack(anchor=tk.W)
        tag = ttk.Combobox(ef_main_frame, values=self.valid_ef_tags, state="readonly")
        tag.pack(anchor=tk.W)
        means_frame = ttk.Frame(ef_main_frame)
        means_frame.pack(anchor=tk.W, pady=2)
        add_means_btn = ttk.Button(means_frame, text="uyguraçı ekle", command=lambda idx=len(self.enforcer_items): self.add_means_to_enforcer(idx))
        add_means_btn.pack(anchor=tk.W)
        means_container = ttk.Frame(means_frame)
        means_container.pack(anchor=tk.W)
        remove_btn = ttk.Button(ef_main_frame, text="uygulayanı kaldır", command=lambda f=ef_main_frame: self.remove_item(f, self.enforcer_items))
        remove_btn.pack(anchor=tk.W, pady=2)
        ef_main_frame.pack(anchor=tk.W, pady=5, fill=tk.X)
        self.enforcer_items.append({'entity': entity, 'tag': tag, 'means': [], 'means_container': means_container})
        self.add_means_to_enforcer(len(self.enforcer_items) - 1)
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))

    def add_means_to_enforcer(self, enforcer_idx):
        item = self.enforcer_items[enforcer_idx]
        m_frame = ttk.Frame(item['means_container'])
        mean_entry = ttk.Entry(m_frame, width=40)
        mean_entry.pack(side=tk.LEFT, padx=(0, 5))
        mean_tag = ttk.Combobox(m_frame, values=self.valid_means_tags, state="readonly", width=10)
        mean_tag.pack(side=tk.LEFT)
        remove_m_btn = ttk.Button(m_frame, text="kaldır", command=lambda mf=m_frame: self.remove_subitem(mf, item['means']))
        remove_m_btn.pack(side=tk.LEFT, padx=5)
        m_frame.pack(anchor=tk.W, pady=1)
        item['means'].append({'mean_entry': mean_entry, 'mean_tag': mean_tag})
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))

    def add_repeater(self):
        rp_main_frame = ttk.Frame(self.repeaters_container)
        entity_label = ttk.Label(rp_main_frame, text="varlık:")
        entity_label.pack(anchor=tk.W)
        entity = ttk.Entry(rp_main_frame, width=50)
        entity.pack(anchor=tk.W)
        tag_label = ttk.Label(rp_main_frame, text="törelmelik belirteç:")
        tag_label.pack(anchor=tk.W)
        tag = ttk.Combobox(rp_main_frame, values=self.valid_rp_tags, state="readonly")
        tag.pack(anchor=tk.W)
        dp_frame = ttk.Frame(rp_main_frame)
        dp_frame.pack(anchor=tk.W, pady=2)
        add_dp_btn = ttk.Button(dp_frame, text="gösterim ekle", command=lambda idx=len(self.repeater_items): self.add_dp_to_repeater(idx))
        add_dp_btn.pack(anchor=tk.W)
        dp_container = ttk.Frame(dp_frame)
        dp_container.pack(anchor=tk.W)
        remove_btn = ttk.Button(rp_main_frame, text="uygulayanı kaldır", command=lambda f=rp_main_frame: self.remove_item(f, self.repeater_items))
        remove_btn.pack(anchor=tk.W, pady=2)
        rp_main_frame.pack(anchor=tk.W, pady=5, fill=tk.X)
        self.repeater_items.append({'entity': entity, 'tag': tag, 'displayments': [], 'dp_container': dp_container})
        self.add_dp_to_repeater(len(self.repeater_items) - 1)
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))

    def add_dp_to_repeater(self, repeater_idx):
        item = self.repeater_items[repeater_idx]
        dp_frame = ttk.Frame(item['dp_container'])
        dp_entry = ttk.Entry(dp_frame, width=40)
        dp_entry.pack(side=tk.LEFT, padx=(0, 5))
        dp_tag = ttk.Combobox(dp_frame, values=self.valid_displayment_tags, state="readonly", width=10)
        dp_tag.pack(side=tk.LEFT)
        remove_dp_btn = ttk.Button(dp_frame, text="kaldır", command=lambda df=dp_frame: self.remove_subitem(df, item['displayments']))
        remove_dp_btn.pack(side=tk.LEFT, padx=5)
        dp_frame.pack(anchor=tk.W, pady=1)
        item['displayments'].append({'dp_entry': dp_entry, 'dp_tag': dp_tag})
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))

    def add_rejecter(self):
        frame = ttk.Frame(self.rejecters_container)
        entity = ttk.Entry(frame, width=40)
        entity.pack(side=tk.LEFT, padx=(0, 5))
        tag = ttk.Combobox(frame, values=self.valid_re_tags, state="readonly", width=10)
        tag.pack(side=tk.LEFT)
        remove_btn = ttk.Button(frame, text="kaldır", command=lambda f=frame: self.remove_item(f, self.rejecter_items))
        remove_btn.pack(side=tk.LEFT, padx=5)
        frame.pack(anchor=tk.W, pady=1)
        self.rejecter_items.append({'entity': entity, 'tag': tag})
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))

    def add_accepter(self):
        frame = ttk.Frame(self.accepters_container)
        entity = ttk.Entry(frame, width=40)
        entity.pack(side=tk.LEFT, padx=(0, 5))
        tag = ttk.Combobox(frame, values=self.valid_ac_tags, state="readonly", width=10)
        tag.pack(side=tk.LEFT)
        remove_btn = ttk.Button(frame, text="kaldır", command=lambda f=frame: self.remove_item(f, self.accepter_items))
        remove_btn.pack(side=tk.LEFT, padx=5)
        frame.pack(anchor=tk.W, pady=1)
        self.accepter_items.append({'entity': entity, 'tag': tag})
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))

    def remove_item(self, frame, items_list):
        for i, item in enumerate(items_list):
            if item['entity'] in frame.winfo_children() or frame.winfo_children():
                del items_list[i]
                break
        frame.destroy()
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))

    def remove_subitem(self, sub_frame, sub_list):
        for i, sub in enumerate(sub_list):
            if ('mean_entry' in sub and sub['mean_entry'] in sub_frame.winfo_children()) or ('dp_entry' in sub and sub['dp_entry'] in sub_frame.winfo_children()):
                del sub_list[i]
                break
        sub_frame.destroy()
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))

    def _update_scrollregion(self, event):
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))

    def _on_mousewheel(self, event):
        if event.delta:
            self.canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")
        elif event.num == 4:
            self.canvas.yview_scroll(-1, "units")
        elif event.num == 5:
            self.canvas.yview_scroll(1, "units")

    def copy_chain(self):
        try:
            chain_text = self.result_text.get("1.0", tk.END).strip()
            if not chain_text:
                messagebox.showwarning("Warning", "alınılacak törelmelik bağma yok. bir törelmelik bağma kurun .")
                return
            self.root.clipboard_clear()
            self.root.clipboard_append(chain_text)
            self.root.update()
            messagebox.showinfo("başarıldı", "törelmelik bağma alındı")
        except Exception as e:
            messagebox.showerror("yanlış sonuç", f"törelmelik bağma alınılamadı: {str(e)}")

    def update_statement_colors(self, event=None):
        try:
            statement = self.statement_text.get("1.0", tk.END).strip()
            values = self.values_text.get("1.0", tk.END).strip()
            parts = self.parts_text.get("1.0", tk.END).strip()
            limits = self.limits_text.get("1.0", tk.END).strip()

            self.statement_text.tag_remove("values", "1.0", tk.END)
            self.statement_text.tag_remove("parts", "1.0", tk.END)
            self.statement_text.tag_remove("limits", "1.0", tk.END)

            value_list = [v.strip() for v in values.split(",") if v.strip()]
            value_list = [re.sub(r'^\s*[0-9]+\.\s*', '', v).strip() for v in value_list]
            parts_list = [p.strip() for p in parts.split(",") if p.strip()]
            parts_list = [re.sub(r'^\s*[0-9]+\.\s*', '', p).strip() for p in parts_list]
            limits_list = [l.strip() for l in limits.split(",") if l.strip()]
            limits_list = [re.sub(r'^\s*[0-9]+\.\s*', '', l).strip() for l in limits_list]

            components = [(v, "values") for v in value_list] + [(p, "parts") for p in parts_list] + [(l, "limits") for l in limits_list]

            component_positions = []
            for comp, tag in components:
                start = statement.find(comp)
                if start != -1:
                    component_positions.append((start, start + len(comp), comp, tag))
            component_positions.sort()

            for start, end, comp, tag in component_positions:
                self.statement_text.tag_add(tag, f"1.0+{start}c", f"1.0+{start + len(comp)}c")
            return component_positions
        except Exception as e:
            self.result_text.configure(state="normal")
            self.result_text.delete("1.0", tk.END)
            self.result_text.insert("1.0", f"araştırdığınız töreli anlatımın Kesımlerı boyanılamadı: {str(e)}")
            self.result_text.configure(state="disabled")
            return []

    def validate_chain(self):
        try:
            # Source and statement compatibility
            source_tag = self.source_tag.get()
            st_tag = self.statement_tag.get()
            if not source_tag or not st_tag:
                return False, "töreli kaynağın ile töreli anlatımın törelmelik belirteçleri gereklidir."
            expected_statement = self.valid_source_statement_pairs.get(source_tag)
            if not expected_statement:
                return False, f"kaynak törelmelik belirteç '{source_tag}' bir töreli kaynağın geçerli törelmelik belirteçlerinden birisi değildir. geçerli törelmelik belirteçleri: {', '.join(self.valid_source_tags)}."
            if st_tag != expected_statement:
                return False, f"anlatım törelmelik belirteç '{st_tag}' kaynak törelmelik belirteç ile uyumsuzdur '{source_tag}'. beklenen anlatım törelmelik belirteçi: '{expected_statement}'."

            # Function/process for source and statement
            extra_source = self.extra_source_entry.get().strip()
            if source_tag in self.function_source_tags and not extra_source:
                return False, f"kaynak törelmelik belirteç '{source_tag}' bir töreli işlevi gerektirir ancak bu verilmedi."
            if source_tag in self.process_source_tags and not extra_source:
                return False, f"kaynak törelmelik belirteç '{source_tag}' bir töreli anlatım üretim işlemi gerektirir ancak bu verilmedi."
            if extra_source and source_tag not in (self.function_source_tags + self.process_source_tags):
                return False, f"kaynak törelmelik belirteç '{source_tag}' bir töreli işlevi yoksa töreli anlatım üretim işlemi gerektirmez ancak bu verildi: '{extra_source}'."
            
            extra_statement = self.extra_statement_entry.get().strip()
            if st_tag in self.function_statement_tags and not extra_statement:
                return False, f"anlatım törelmelik belirteç '{st_tag}' bir töreli işlevi gerektirir ancak bu verilmedi."
            if st_tag in self.process_statement_tags and not extra_statement:
                return False, f"anlatım törelmelik belirteç '{st_tag}' bir töreli anlatım üretim işlemi gerektirir ancak bu verilmedi."
            if extra_statement and st_tag not in (self.function_statement_tags + self.process_statement_tags):
                return False, f"anlatım törelmelik belirteç '{st_tag}' bir töreli işlevi yoksa töreli anlatım üretim işlemi gerektirmez ancak bu verildi: '{extra_statement}'."

            # Values validation
            value_tags = [item[1].get() for item in self.value_items]
            if not value_tags or any(not vt for vt in value_tags):
                return False, "bir yoksa birden cok törelmelik belirteçi olan töreli deegerler gereklidir."
            valid_values = self.valid_statement_value_pairs.get(st_tag, {}).get('values', [])
            if not valid_values:
                return False, f"töreli anlatım törelmelik belirteç '{st_tag}' geçerli bir anlatımin törelmelik belirteçi değildir. geçerli törelmelik belirteçileri: {', '.join(self.valid_statement_tags)}."
            required_value = self.valid_statement_value_pairs.get(st_tag, {}).get('required', '')
            for vt in value_tags:
                if vt not in valid_values:
                    return False, f"töreli değer törelmelik belirteç '{vt}' arastidiginiz töreli anlatım için geçersizdir '{st_tag}'. geçerli töreli değer törelmelik belirteçleri: {', '.join(valid_values)}."
            if required_value and required_value not in value_tags:
                return False, f"gerekli töreli değer törelmelik belirteç '{required_value}' töreli anlatım için verilmeli '{st_tag}'."

            # Displayment validation
            displayment_desc = self.displayment_input.get().strip()
            displayment_tag = self.displayment_tag.get()
            if displayment_desc and not displayment_tag:
                return False, "gösterim törelmelik belirteç verilmelidir eğer gösterimin kendisi verildiyse."
            if displayment_tag and not displayment_desc:
                return False, f"gösterim törelmelik belirteç'{displayment_tag}' gösterimin kendisi verilmedi."
            if displayment_tag and displayment_tag not in self.valid_displayment_tags:
                return False, f"geçersiz gösterim törelmelik belirteç'{displayment_tag}'. geçerli gösterim törelmelik belirteç: {', '.join(self.valid_displayment_tags)}."

            # Interactor validation
            for items, type_name, valid_tags, has_subcomponents in [
                (self.non_interactor_items, "Non-interactor", self.valid_ni_tags, False),
                (self.enforcer_items, "Enforcers", self.valid_ef_tags, True),
                (self.repeater_items, "Repeaters", self.valid_rp_tags, True),
                (self.rejecter_items, "Rejecters", self.valid_re_tags, False),
                (self.accepter_items, "Accepters", self.valid_ac_tags, False)
            ]:
                for item in items:
                    entity = item['entity'].get().strip()
                    tag = item['tag'].get()
                    if not entity and tag:
                        return False, f"varlığın bilgisi gereklidir {type_name} törelmelik belirteçleri: '{tag}'."
                    if entity and not tag:
                        return False, f"törelmelik belirteç sonraki varkli için gereklidir: {type_name} '{entity}'."
                    if tag and tag not in valid_tags:
                        return False, f"geçersiz {type_name} törelmelik belirteç: '{tag}'. geçerli törelmelik belirteçler: {', '.join(valid_tags)}."
                    if has_subcomponents and entity:
                        subcomponents = item.get('means', []) or item.get('displayments', [])
                        if not subcomponents:
                            return False, f"{type_name} '{entity} ({tag})' bir yoksa birden çok gösterim/uyguraçı gerekli."
                        for sub in subcomponents:
                            sub_desc = sub.get('mean_entry', sub.get('dp_entry')).get().strip()
                            sub_tag = sub.get('mean_tag', sub.get('dp_tag')).get()
                            if not sub_desc and sub_tag:
                                return False, f"uyguraçı/gösterim bilgisi {type_name} '{entity}' için gereklidir: '{sub_tag}'."
                            if sub_desc and not sub_tag:
                                return False, f"uyguraçı/gösterim bilgisi {type_name} '{entity}' için gereklidir: '{sub_desc}'."
                            valid_sub_tags = self.valid_means_tags if type_name == "Enforcers" else self.valid_displayment_tags
                            if sub_tag and sub_tag not in valid_sub_tags:
                                return False, f"geçersiz {type_name} uyguraçı/gösterim '{sub_tag}' '{entity} için'. geçerli törelmelik belirteçler: {', '.join(valid_sub_tags)}."
                    elif (entity and 'means' in item and item['means']) or (entity and 'displayments' in item and item['displayments']):
                        return False, f"{type_name} '{entity} ({tag})' uyguraçıları/gösterimler verildi ancak burada geçerli değiller."

            # Required INI tags
            has_required_value = any(vt in self.required_values for vt in value_tags)
            if has_required_value:
                all_ini_tags = (
                    [item['tag'].get() for item in self.non_interactor_items if item['tag'].get()] +
                    [item['tag'].get() for item in self.enforcer_items if item['tag'].get()] +
                    [item['tag'].get() for item in self.repeater_items if item['tag'].get()] +
                    [item['tag'].get() for item in self.rejecter_items if item['tag'].get()] +
                    [item['tag'].get() for item in self.accepter_items if item['tag'].get()]
                )
                if not any(tag in self.required_ini_tags for tag in all_ini_tags):
                    return False, f"verdiğiniz töreli değerler yüzünden törelmelik bağmanız biryoksa birden çok ETM törelmelik belirteçleri gerektirir({', '.join(value_tags)}). Valid INI tags are: {', '.join(self.required_ini_tags)}."

            # Accepter compatibility
            for item in self.accepter_items:
                ac_entity = item['entity'].get().strip()
                ac_tag = item['tag'].get()
                if ac_entity and ac_tag in ['OL11', 'OL12', 'OL13', 'OL14', 'OL15']:
                    compat_tags = self.ac_compat.get(ac_tag, [])
                    if not compat_tags:
                        return False, f"onaylayan törelmelik belirteçi'{ac_tag}' uyum kurallarına uygun değildir."
                    found = False
                    for ef_item in self.enforcer_items:
                        ef_entity = ef_item['entity'].get().strip()
                        ef_tag = ef_item['tag'].get()
                        if ef_entity == ac_entity and ef_tag in compat_tags:
                            found = True
                            break
                    if not found:
                        for rp_item in self.repeater_items:
                            rp_entity = rp_item['entity'].get().strip()
                            rp_tag = rp_item['tag'].get()
                            if rp_entity == ac_entity and rp_tag in compat_tags:
                                found = True
                                break
                    if not found:
                        return False, f"onaylayan '{ac_entity}' ({ac_tag}) bir özdeş olan varlığı bir uyumlu uygulayan olarak yoksa bir uyumlu tekrarlayan olarak ile onun törelmelik belirteçini gerektirir: {', '.join(compat_tags)}."

            return True, ""
        except Exception as e:
            return False, f"geçerlilik deneme yanlışlığı yer aldı: {str(e)}"

    def apply_formatting(self, chain_text):
        component_positions = self.update_statement_colors()
        statement_start = chain_text.find("moral statement [") + len("moral statement [")
        statement_end = chain_text.find("]", statement_start)
        for start, end, comp, tag in component_positions:
            self.result_text.tag_add(tag, f"1.0+{statement_start + start}c", f"1.0+{statement_start + end}c")
        keywords = ["töreli kaynak", "töreli anlatım", "töreli değerler", "gösterimler", "etkilenmeyenler", "uygulayanlar", "tekrarlayanlar", "onaylamayanlar", "onaylayanlar", "uyguraçları"]
        for keyword in keywords:
            start_pos = 0
            while True:
                start_pos = chain_text.find(keyword, start_pos)
                if start_pos == -1:
                    break
                self.result_text.tag_add("bold", f"1.0+{start_pos}c", f"1.0+{start_pos + len(keyword)}c")
                start_pos += len(keyword)

    def generate_chain(self):
        try:
            if not self.source_text.get().strip() or not self.statement_text.get("1.0", tk.END).strip():
                messagebox.showerror("yanlış sonuç", "töreli kaynağın kimliği ile töreli anlatım gereklidir.")
                return

            valid, error = self.validate_chain()
            if not valid:
                self.result_text.delete("1.0", tk.END)
                self.result_text.insert("1.0", f"Error: {error}")
                return

            source_identity = self.source_text.get().strip()
            source_tag = self.source_tag.get()
            extra_source = self.extra_source_entry.get().strip()
            statement = self.statement_text.get("1.0", tk.END).strip()
            st_tag = self.statement_tag.get()
            extra_statement = self.extra_statement_entry.get().strip()
            value_list = [item[0] for item in self.value_items]
            value_tags = [item[1].get() for item in self.value_items]
            displayment_desc = self.displayment_input.get().strip()
            displayment_tag = self.displayment_tag.get()

            # Build source part
            source_part = f"moral source [{source_identity} ({source_tag})"
            if extra_source:
                if source_tag in self.function_source_tags:
                    source_part += f", moral function ({extra_source})"
                elif source_tag in self.process_source_tags:
                    source_part += f", moral statement production process ({extra_source})"
            source_part += "]"

            # Build statement part
            statement_part = f"- moral statement [{statement} ({st_tag})"
            if extra_statement:
                if st_tag in self.function_statement_tags:
                    statement_part += f", moral function ({extra_statement})"
                elif st_tag in self.process_statement_tags:
                    statement_part += f", moral statement production process ({extra_statement})"
            values_str = ". ".join([f"{v} ({vt})" for v, vt in zip(value_list, value_tags)])
            statement_part += f", Moral Values ({values_str})]"
            chain = source_part + statement_part

            # Displayments
            if displayment_desc and displayment_tag:
                chain += f"- Displayments [{displayment_desc} ({displayment_tag})]"

            # Non-interactors
            if self.non_interactor_items:
                ni_str = ". ".join([f"{item['entity'].get().strip()} ({item['tag'].get()})" for item in self.non_interactor_items])
                chain += f"- Non-interactor [{ni_str}]"

            # Enforcers
            if self.enforcer_items:
                ef_str = ". ".join([
                    f"{item['entity'].get().strip()} ({item['tag'].get()})" +
                    (f", Means ({'. '.join([f"{m['mean_entry'].get().strip()} ({m['mean_tag'].get()})" for m in item['means']])})" if item['means'] else "")
                    for item in self.enforcer_items
                ])
                chain += f"- Enforcers [{ef_str}]"

            # Repeaters
            if self.repeater_items:
                rp_str = ". ".join([
                    f"{item['entity'].get().strip()} ({item['tag'].get()})" +
                    (f", Displayments ({'. '.join([f"{d['dp_entry'].get().strip()} ({d['dp_tag'].get()})" for d in item['displayments']])})" if item['displayments'] else "")
                    for item in self.repeater_items
                ])
                chain += f"- Repeaters [{rp_str}]"

            # Rejecters
            if self.rejecter_items:
                re_str = ". ".join([f"{item['entity'].get().strip()} ({item['tag'].get()})" for item in self.rejecter_items])
                chain += f"- Rejecters [{re_str}]"

            # Accepters
            if self.accepter_items:
                ac_str = ". ".join([f"{item['entity'].get().strip()} ({item['tag'].get()})" for item in self.accepter_items])
                chain += f"- Accepters [{ac_str}]"

            self.result_text.delete("1.0", tk.END)
            chain_text = chain
            self.result_text.insert("1.0", chain_text)
            self.apply_formatting(chain_text)
            self.chain_text = chain_text
        except Exception as e:
            self.result_text.delete("1.0", tk.END)
            self.result_text.insert("1.0", f"Error: beklenilmeyen oldu: {str(e)}")

    def split_top_level(self, s, delimiter=','):
        """Split string by delimiter outside of balanced parentheses."""
        parts = []
        current = ''
        paren_count = 0
        i = 0
        while i < len(s):
            char = s[i]
            current += char
            if char == '(':
                paren_count += 1
            elif char == ')':
                paren_count -= 1
            elif char == delimiter and paren_count == 0:
                parts.append(current[:-1].strip())  # Remove the delimiter
                current = ''
            i += 1
        if current:
            parts.append(current.strip())
        return parts

    def extract_balanced(self, s, start_pos):
        """Extract balanced substring starting from start_pos until matching closing parenthesis."""
        paren_count = 0
        i = start_pos
        start_char = s[i] if i < len(s) else None
        if start_char != '(':
            return ''
        paren_count = 1  # Start with the opening (
        i += 1
        while i < len(s) and paren_count > 0:
            char = s[i]
            if char == '(':
                paren_count += 1
            elif char == ')':
                paren_count -= 1
            i += 1
        return s[start_pos:i]

    def parse_entity_tag(self, part):
        """Parse 'entity (tag)' from a part."""
        match = re.match(r'(.*?) \s* \( \s* ([A-Z0-9]+) \s* \) \s* $', part.strip(), re.X)
        if match:
            return match.group(1).strip(), match.group(2).strip()
        return None, None

    def parse_optional_part(self, part, key_word, tag_set):
        """Parse optional part like 'Means (text (tag))'."""
        part_lower = part.lower().strip()
        if key_word.lower() not in part_lower:
            return ''
        # Find the opening ( after key_word
        start = part_lower.find('(')
        if start == -1:
            return ''
        content = self.extract_balanced(part, start)
        if not content:
            return ''
        # Parse content as text (tag)
        match = re.match(r'\s* (.*?) \s* \( \s* ([A-Z0-9]+) \s* \) \s* $', content[1:-1].strip(), re.X)  # Skip outer ( )
        if match:
            text = match.group(1).strip()
            tag = match.group(2).strip()
            if tag in tag_set:
                return f"{text} ({tag})"
        return ''

    def parse_moralithic_chain(self, chain_text):
        if chain_text.startswith("Generated Chain: "):
            chain_text = chain_text.replace("Generated Chain: ", "")
        sections = re.split(r'-\s*', chain_text)

        extracted = {'interactors': []}

        for section in sections:
            section = section.strip()
            if not section:
                continue
            if section.startswith("moral source ["):
                source_match = re.match(r"moral source \[\s*(.*?) \s*\((.*?)\)\s*(?:,\s*(moral function|moral statement production process)\s*\((.*?)\))?\s*\]", section)
                if source_match:
                    extracted['source_text'] = source_match.group(1)
                    extracted['source_tag'] = source_match.group(2)
                    extracted['extra_source_type'] = source_match.group(3)
                    extracted['extra_source'] = source_match.group(4)
                else:
                    return None  # Failed to parse source
            elif section.startswith("moral statement ["):
                # Capture the entire content inside [ ]
                content_match = re.match(r"moral statement \[(.*?)\]", section, re.DOTALL)
                if not content_match:
                    return None
                content = content_match.group(1).strip()
                # Split by top-level ,
                parts = self.split_top_level(content)
                if len(parts) < 1:
                    return None
                # First part: statement_text (tag)
                st_match = self.parse_entity_tag(parts[0])
                if not st_match[0] or not st_match[1]:
                    return None
                extracted['statement_text'] = st_match[0]
                extracted['statement_tag'] = st_match[1]
                # Second part if present: extra statement
                if len(parts) > 1:
                    extra_part = parts[1].strip()
                    extra_match = re.match(r"(moral function|moral statement production process) \s* \( \s* (.*?) \s* \) \s* $", extra_part, re.X)
                    if extra_match:
                        extracted['extra_statement_type'] = extra_match.group(1)
                        extracted['extra_statement'] = extra_match.group(2)
                # Subsequent parts: Moral Values, Necessary Parts, Limitations
                moral_values = ''
                necessary_parts = ''
                limitations = ''
                for p in parts[2:]:
                    p_lower = p.lower().strip()
                    if 'moral values' in p_lower:
                        start = p.find('(')
                        if start != -1:
                            moral_values = self.extract_balanced(p, start)
                    elif 'necessary parts' in p_lower:
                        start = p.find('(')
                        if start != -1:
                            necessary_parts = self.extract_balanced(p, start)
                    elif 'limitations' in p_lower:
                        start = p.find('(')
                        if start != -1:
                            limitations = self.extract_balanced(p, start)
                extracted['moral_values'] = moral_values
                extracted['necessary_parts'] = necessary_parts
                extracted['limitations'] = limitations
            elif section.startswith("Displayments ["):
                displayments_match = re.match(r"Displayments \[\s*(.*?)\s*\]", section)
                if displayments_match:
                    extracted['displayments'] = displayments_match.group(1)
            elif section.startswith("Non-interactor ["):
                ni_match = re.match(r"Non-interactor \[\s*(.*?)\s*\]", section)
                if ni_match:
                    ni_str = ni_match.group(1)
                    ni_items = re.findall(r"(\d+\.\s*)?(.*?) \s*\(\s*([A-Z0-9]+)\s*\)", ni_str)
                    for _, entity, tag in ni_items:
                        extracted['interactors'].append({'type': 'Non-interactor', 'entity': entity.strip(), 'tag': tag.strip(), 'transformations': []})
            elif section.startswith("Enforcers ["):
                ef_match = re.match(r"Enforcers \[\s*(.*?)\s*\]", section)
                if ef_match:
                    ef_content = ef_match.group(1).strip()
                    # Split top-level ,
                    ef_parts = self.split_top_level(ef_content)
                    for part in ef_parts:
                        # Parse entity (tag)
                        entity, tag = self.parse_entity_tag(part)
                        if not entity or not tag:
                            continue
                        means = ''
                        # Check if this part has Means
                        if ', Means' in part:
                            means_part = part.split(', Means', 1)[1].strip()
                            start = means_part.find('(')
                            if start != -1:
                                means_content = self.extract_balanced(means_part, start)
                                if means_content:
                                    # Parse text (tag) inside means_content
                                    m_text, m_tag = self.parse_entity_tag(means_content[1:-1])  # Skip outer ( )
                                    if m_text and m_tag and m_tag in self.valid_means_tags:
                                        means = f"{m_text} ({m_tag})"
                        extracted['interactors'].append({'type': 'Enforcer', 'entity': entity, 'tag': tag, 'means': means, 'transformations': []})
            elif section.startswith("Repeaters ["):
                rp_match = re.match(r"Repeaters \[\s*(.*?)\s*\]", section)
                if rp_match:
                    rp_content = rp_match.group(1).strip()
                    # Split top-level ,
                    rp_parts = self.split_top_level(rp_content)
                    for part in rp_parts:
                        # Parse entity (tag)
                        entity, tag = self.parse_entity_tag(part)
                        if not entity or not tag:
                            continue
                        displayments = ''
                        # Check if this part has Displayments
                        if ', Displayments' in part:
                            dp_part = part.split(', Displayments', 1)[1].strip()
                            start = dp_part.find('(')
                            if start != -1:
                                dp_content = self.extract_balanced(dp_part, start)
                                if dp_content:
                                    # Parse text (tag) inside dp_content
                                    d_text, d_tag = self.parse_entity_tag(dp_content[1:-1])  # Skip outer ( )
                                    if d_text and d_tag and d_tag in self.valid_displayment_tags:
                                        displayments = f"{d_text} ({d_tag})"
                        extracted['interactors'].append({'type': 'Repeater', 'entity': entity, 'tag': tag, 'displayments': displayments, 'transformations': []})
            elif section.startswith("Rejecters ["):
                re_match = re.match(r"Rejecters \[\s*(.*?)\s*\]", section)
                if re_match:
                    re_str = re_match.group(1)
                    re_items = re.findall(r"(\d+\.\s*)?(.*?) \s*\(\s*([A-Z0-9]+)\s*\)", re_str)
                    for _, entity, tag in re_items:
                        extracted['interactors'].append({'type': 'Rejecter', 'entity': entity.strip(), 'tag': tag.strip(), 'transformations': []})
            elif section.startswith("Accepters ["):
                ac_match = re.match(r"Accepters \[\s*(.*?)\s*\]", section)
                if ac_match:
                    ac_str = ac_match.group(1)
                    ac_items = re.findall(r"(\d+\.\s*)?(.*?) \s*\(\s*([A-Z0-9]+)\s*\)", ac_str)
                    for _, entity, tag in ac_items:
                        extracted['interactors'].append({'type': 'Accepter', 'entity': entity.strip(), 'tag': tag.strip(), 'transformations': []})

        if 'statement_tag' not in extracted or not extracted['statement_tag']:
            return None
        return extracted

    def validate_extracted_moralithic(self, extracted):
        statement_tag = extracted.get('statement_tag', '')
        source_tag = extracted.get('source_tag', '')
        if not statement_tag:
            return False, "töreli anlatımın törelmelik belirteç bulunamadı. bunu düzeltin."
        if not source_tag:
            return False, "töreli kaynağın törelmelik belirteç bulunamadı. bunu düzeltin."
        if statement_tag not in self.valid_statement_source_pairs:
            return False, f"geçersiz anlatım törelmelik belirteçi '{statement_tag}'."
        if self.valid_statement_source_pairs[statement_tag] != source_tag:
            return False, f"uyumsuz anlatım törelmelik belirteçi '{statement_tag}' kaynak törelmelik belirteçi ile '{source_tag}'. beklenen '{self.valid_statement_source_pairs[statement_tag]}'."

        moral_values = extracted.get('moral_values', '')
        value_tags = []
        if moral_values:
            # Extract tags from values content
            value_items = re.findall(r'\d*\.?\s*(.*?)\s*\(\s*([A-Z0-9]+)\s*\)', moral_values)
            value_tags = [v[1] for v in value_items]
            if not value_tags:
                return False, " geçerli töreli değerler alınılamadı. verdiğiniz töreli değerleri düzeltin. (...)."
        if not value_tags:
            return False, "töreli değerler bulunamadı. bir yoksa birden çok töreli değerler verin."
        valid_values = self.valid_statement_value_pairs.get(statement_tag, {}).get('values', [])
        invalid_values = [v for v in value_tags if v not in valid_values]
        if invalid_values:
            return False, f"töreli anlatım için geçersiz değer törelmelik belirteçi '{statement_tag}': {', '.join(invalid_values)}. geçerli olan: {', '.join(valid_values)}"

        for idx, inter in enumerate(extracted['interactors']):
            tag = inter['tag']
            if not tag:
                return False, f"{inter['type']} için törelmelik belirteçi bulunamadı '{inter['entity']}' yerinde {idx+1}."
            if tag not in self.valid_interaction_tags:
                return False, f"geçersiz etkileyen törelmelik belirteç '{tag}' icin {inter['type']} '{inter['entity']}'."
            if inter['type'] == 'Enforcer' and inter.get('means'):
                means_items = re.findall(r'\d*\.?\s*(.*?)\s*\(\s*([A-Z0-9]+)\s*\)', inter['means'])
                means_tags = [m[1] for m in means_items]
                if not means_tags:
                    return False, f"geçerli uyguraçı törelmelik belirteçi alınılamadı '{inter['entity']}'. bunu düzeltin."
                invalid_means = [mt for mt in means_tags if mt not in self.valid_means_tags]
                if invalid_means:
                    return False, f"uygulayan için geçersiz uyguraçı törelmelik belirteçi: '{inter['entity']}': {', '.join(invalid_means)}. geçerli: {', '.join(self.valid_means_tags)}"
            if inter['type'] == 'Repeater' and inter.get('displayments'):
                dp_items = re.findall(r'\d*\.?\s*(.*?)\s*\(\s*([A-Z0-9]+)\s*\)', inter['displayments'])
                dp_tags = [d[1] for d in dp_items]
                if not dp_tags:
                    return False, f"tekrarlayan için geçerli gösterim törelmelik belirteçi alınılamadı: '{inter['entity']}'. bunu düzeltin."
                invalid_dp = [dt for dt in dp_tags if dt not in self.valid_displayment_tags]
                if invalid_dp:
                    return False, f"tekrarlayan için geçersiz gösterim törelmelik belirteçi:'{inter['entity']}': {', '.join(invalid_dp)}. geçerli: {', '.join(self.valid_displayment_tags)}"

        return True, ""

    def setup_footnotes(self):
        chain_input = self.result_text.get("1.0", tk.END).strip()
        if not chain_input:
            messagebox.showerror("yanlış sonuç", " önce bir törelmelik bağma kurun.")
            return

        # Clear previous state
        self.interactors = []
        for widget in self.footnote_container.winfo_children():
            widget.destroy()

        try:
            extracted = self.parse_moralithic_chain(chain_input)
            if not extracted:
                messagebox.showerror("yanlış sonuç", "geçersiz törelmelik bağma yapımı. bölümlerin ayrıştırılması başarısız oldu (örnegin: töreli kaynak, töreli anlatım, etkilenenler). doğru biçimde işletiniz (-).")
                return
            valid, error = self.validate_extracted_moralithic(extracted)
            if not valid:
                messagebox.showerror("yanlış sonuç", f"geçerlilik becerilemedi: {error}")
                return
            self.chain_text = chain_input
            self.interactors = extracted['interactors']

            transformable_interactors = [inter for inter in self.interactors if not inter['tag'].startswith("RP")]
            if not transformable_interactors:
                messagebox.showinfo("bilgi", "değişebilecek etkileyen yok (tek tekrarlayan saptama edildi).")
                return
            for idx, inter in enumerate(transformable_interactors):
                orig_idx = self.interactors.index(inter)
                self.add_footnote_frame(inter['tag'], orig_idx)
            self.root.update_idletasks()

        except Exception as e:
            messagebox.showerror("yanlış sonuç", f"geçerlilik becerme denemesinde beklenilmeyen yanlışlık çıktı: {str(e)}")

    def add_footnote_frame(self, tag, idx):
        frame = ttk.Frame(self.footnote_container)
        frame.pack(anchor=tk.W, pady=5, fill=tk.X)
        label_text = f" degisim ekle: {self.interactors[idx]['type']} '{self.interactors[idx]['entity']}' ({tag}):"
        ttk.Label(frame, text=label_text).pack(anchor=tk.W)
        combobox = ttk.Combobox(frame, state="readonly", width=20)
        combobox.pack(anchor=tk.W, pady=2)
        valid_transformations = []
        if tag in self.conversion_rules:
            valid_transformations.extend([f"{tag}->{prev}" for prev in self.conversion_rules[tag]])
        if tag in self.transformation_rules:
            valid_transformations.extend([f"{tag}->{prev}" for prev in self.transformation_rules[tag]])
        combobox['values'] = valid_transformations
        combobox['state'] = 'readonly' if valid_transformations else 'disabled'
        add_btn = ttk.Button(frame, text="degisim ekle", command=lambda c=combobox, i=idx: self.add_transformation(c, i))
        add_btn.pack(anchor=tk.W, pady=5)
        self.interactors[idx]['footnote_frame'] = frame
        self.interactors[idx]['combobox'] = combobox
        self.root.update_idletasks()

    def add_transformation(self, combobox, idx):
        try:
            transformation = combobox.get()
            if not transformation:
                messagebox.showerror("yanlış sonuç", "seçeneklerden bir değişim seçin.")
                return
            current_tag, prev_tag = transformation.split("->")
            valid, error = self.validate_transformation(current_tag, prev_tag)
            if not valid:
                messagebox.showerror("yanlış sonuç", f"geçersiz değişim: {error}")
                return
            self.interactors[idx]['transformations'].append(transformation)
            current_tag = prev_tag
            valid_transformations = []
            if current_tag in self.conversion_rules:
                valid_transformations.extend([f"{current_tag}->{p}" for p in self.conversion_rules[current_tag]])
            if current_tag in self.transformation_rules:
                valid_transformations.extend([f"{current_tag}->{p}" for p in self.transformation_rules[current_tag]])
            combobox['values'] = valid_transformations
            combobox.set('')
            combobox['state'] = 'readonly' if valid_transformations else 'disabled'
            self.update_chain_with_footnote()
        except Exception as e:
            messagebox.showerror("yanlış sonuç", f"değişim eklenilemedi: {str(e)}")

    def update_chain_with_footnote(self):
        try:
            footnotes = []
            for inter in self.interactors:
                if inter.get('transformations'):
                    trans_chain = [inter['tag']]
                    for trans in inter['transformations']:
                        _, new = trans.split('->')
                        trans_chain.append(new)
                    trans_chain = trans_chain[::-1]
                    trans_str = '->'.join(trans_chain)
                    footnotes.append(f"{inter['type']} '{inter['entity']}' underwent {len(inter['transformations'])} transformation{'s' if len(inter['transformations']) > 1 else ''}: {trans_str}")
            footnote = ""
            if footnotes:
                footnote = f"Footnotes: {'; '.join(footnotes)}\n"

            self.result_text.configure(state="normal")
            self.result_text.delete("1.0", tk.END)
            self.result_text.insert("1.0", self.chain_text + "\n" + footnote)
            self.result_text.configure(state="disabled")
        except Exception as e:
            messagebox.showerror("yanlış sonuç", f"törelmelik bağmayı altbilgiler ile güncellenilemedi: {str(e)}")

    def validate_transformation(self, current_tag, prev_tag):
        if current_tag.startswith("RP"):
            return False, "tekrarlayanlar (TK törelmelik belirteçi) dönüştürelemez."
        if prev_tag.startswith("NI") and not current_tag.startswith("NI"):
            return False, "EM törelmelik belirteçi EM törelmelik belirteçi olmayanlara dönüştürelemez."
        if current_tag in self.conversion_rules and prev_tag in self.conversion_rules[current_tag]:
            return True, ""
        if current_tag in self.transformation_rules and prev_tag in self.transformation_rules[current_tag]:
            return True, ""
        return False, f"{current_tag} den dönüştürelemez  {prev_tag}. {current_tag} dönüşme kurallarına bakın."

if __name__ == "__main__":
    root = tk.Tk()
    root.geometry("900x800")
    app = MoralithicChainGeneratorMode2(root)
    root.mainloop()